<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BLAZING RUNNER | Ultimate Settings</title>
    
    <meta name="author" content="Jamiul Hasan">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght[400;700]&display=swap" rel="stylesheet"> 
    
    <style>
        /* ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ CSS ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá */
        body { 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; 
            background-color: #0f0a1c; 
            font-family: 'Orbitron', sans-serif; 
            user-select: none; touch-action: manipulation;
        }
        #game-container {
            position: relative;
            border: 8px solid #00FFFF; 
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.9); 
            overflow: hidden; 
            touch-action: manipulation;
        }
        canvas { display: block; }

        /* UI Overlay */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.98);
            color: white; display: flex; flex-direction: column; justify-content: center; 
            align-items: center; text-align: center; z-index: 10;
            opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; 
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        h1 { font-size: 4.5em; color: #FF00FF; margin-bottom: 5px; text-shadow: 0 0 10px #FF00FF; } 
        h2 { font-size: 1.8em; color: #00FFFF; margin-top: 5px; text-shadow: 0 0 5px #00FFFF; }
        p.control-hint { font-size: 1.1em; color: #888; margin-top: 15px;}
        p.developer-credit { font-size: 0.9em; color: #444; margin-top: 20px;}

        /* ‡¶¨‡¶æ‡¶ü‡¶® ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶® */
        button {
            padding: 15px 35px; margin-top: 20px; font-size: 1.4em; cursor: pointer;
            background-color: #FF00FF; border: 2px solid #00FFFF;
            color: #0f0a1c; 
            border-radius: 5px;
            box-shadow: 0 0 15px #FF00FF, inset 0 0 5px #00FFFF;
            transition: all 0.15s;
        }
        button:hover { background-color: #00FFFF; box-shadow: 0 0 20px #00FFFF, inset 0 0 5px #FF00FF; }
        button:active { transform: scale(0.95); }

        /* Settings Grid */
        #settings-menu {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .setting-button {
            padding: 10px;
            font-size: 1.1em;
            background-color: #333;
            color: white;
            border: 1px solid #00FFFF;
        }
        .setting-button.selected {
            background-color: #00FFFF;
            color: #0f0a1c;
            box-shadow: 0 0 10px #00FFFF;
        }

        /* ‡¶∏‡ßç‡¶ï‡ßã‡¶∞ ‡¶°‡¶ø‡¶∏‡¶™‡ßç‡¶≤‡ßá */
        #score-display {
            position: absolute; top: 15px; left: 15px; color: #00FFFF; 
            font-size: 1.8em; padding: 8px 18px; background: rgba(0, 0, 0, 0.8);
            border-radius: 5px; letter-spacing: 3px; font-weight: bold;
            text-shadow: 0 0 8px #00FFFF;
            border: 1px solid #00FFFF;
        }
        #mobile-jump-icon {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            color: white;
            pointer-events: none; /* ‡¶Ø‡¶æ‡¶§‡ßá ‡¶ü‡¶æ‡¶ö ‡¶è‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá */
            opacity: 0;
            transition: opacity 0.3s;
        }

        #touch-area { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; cursor: pointer; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="350"></canvas>
        
        <div id="score-display">SCORE: 000000</div>
        <div id="touch-area"></div>
        <div id="mobile-jump-icon">üëÜ</div> <div id="start-screen" class="overlay active">
            <h1>BLAZING RUNNER</h1>
            <h2>ULTRA-FAST ARCADE ACTION</h2>
            
            <div id="settings-menu">
                <button class="setting-button" data-setting="speed" data-value="easy" id="diff-easy">EASY</button>
                <button class="setting-button selected" data-setting="speed" data-value="normal" id="diff-normal">NORMAL</button>
                <button class="setting-button" data-setting="speed" data-value="hard" id="diff-hard">HARD</button>
                <button class="setting-button selected" data-setting="control" data-value="visible" id="ctrl-visible">CONTROL VISIBLE</button>
                <button class="setting-button" data-setting="control" data-value="hidden" id="ctrl-hidden">CONTROL HIDDEN</button>
            </div>
            
            <button id="startButton">START RUN</button>
            <p class="control-hint">Tap anywhere or press SPACE to jump.</p>
            <p class="developer-credit">Developed by: Jamiul Hasan | <a href="https://facebook.com/jamiul2168" target="_blank" style="color:#00FFFF;">jamiul2168</a></p>
        </div>
        
        <div id="game-over-screen" class="overlay">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Final Score: 0</h2>
            <button onclick="location.reload()">RETRY (R)</button>
             <p class="developer-credit">Developed by: Jamiul Hasan</p>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            // --- 1. GAMESTATE & CONFIGS ---
            const GameState = { READY: 'READY', RUNNING: 'RUNNING', OVER: 'OVER' };
            let gameState = GameState.READY;

            // DOM ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶‡ßá ‡¶∏‡¶Ç‡¶ú‡ßç‡¶û‡¶æ‡¶Ø‡¶º‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score-display');
            const gameOverScreen = document.getElementById('game-over-screen');
            const startScreen = document.getElementById('start-screen');
            const touchArea = document.getElementById('touch-area');
            const startButton = document.getElementById('startButton');
            const mobileJumpIcon = document.getElementById('mobile-jump-icon');

            const GROUND_Y = canvas.height - 40;
            
            // DIFFICULTY SETTINGS (NEW)
            const BASE_SPEED = 300;
            const BASE_GRAVITY = 1800;
            const BASE_JUMP = -550;

            const SETTINGS = {
                'easy': { speed: BASE_SPEED * 0.8, gravity: BASE_GRAVITY * 0.8, jump: BASE_JUMP * 0.9 },
                'normal': { speed: BASE_SPEED, gravity: BASE_GRAVITY, jump: BASE_JUMP },
                'hard': { speed: BASE_SPEED * 1.2, gravity: BASE_GRAVITY * 1.1, jump: BASE_JUMP * 1.1 },
                'selected_speed': 'normal',
                'controls_visible': true 
            };
            
            // --- CORE CONSTANTS ---
            const MAX_SPEED = 700; 
            const FPS_MULTIPLIER = 1000; 
            const AI_SUCCESS_THRESHOLD = 5; 
            const AI_GRAVITY_MODIFIER = 200; 
            const DIFFICULTY_INCREMENT = 3; 
            const BOOST_SCORE_INTERVAL = 500;
            const SPEED_BOOST_AMOUNT = 100; 
            const GROUND_TILE_WIDTH = 50; 

            // --- 2. GLOBAL VARIABLES ---
            let GAME_SPEED = SETTINGS.normal.speed;
            let score = 0;
            let highScore = 0;
            let lastBoostScore = 0;
            let frameCount = 0;
            let groundX = 0;
            let mountainX = 0;
            let animationFrameId;
            let lastTime = 0;
            let deltaTime = 0; 
            let jumpFlashTimer = 0; 
            let lastObstacleHeight = 0;
            let lastObstacleSpawnedTime = 0;


            // --- 3. SOUND MANAGER (AUDIO CONTEXT FIX) ---
            const ASSET_PATH = 'assets/';
            let audioContext;

            class SoundManager {
                constructor() {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.warn('Web Audio API not supported. Using standard Audio.');
                        audioContext = null;
                    }

                    this.jumpBuffer = this.loadAudioBuffer('jump.mp3');
                    this.gameOverBuffer = this.loadAudioBuffer('game_over.mp3'); 
                }
                
                // AudioContext ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ
                loadAudioBuffer(filename) {
                    if (!audioContext) return null;
                    const request = new XMLHttpRequest();
                    request.open('GET', ASSET_PATH + filename, true);
                    request.responseType = 'arraybuffer';
                    
                    return new Promise(resolve => {
                        request.onload = function() {
                            audioContext.decodeAudioData(request.response, function(buffer) {
                                resolve(buffer);
                            }, e => console.error(`Error decoding ${filename}:`, e));
                        };
                        request.send();
                    });
                }

                // AudioContext ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶™‡ßç‡¶≤‡ßá ‡¶ï‡¶∞‡¶æ
                play(bufferPromise) {
                    if (!audioContext) return;
                    bufferPromise.then(buffer => {
                        if (buffer) {
                            const source = audioContext.createBufferSource();
                            source.buffer = buffer;
                            source.connect(audioContext.destination);
                            source.start(0);
                        }
                    });
                }

                playJump() { this.play(this.jumpBuffer); }
                playGameOver() { this.play(this.gameOverBuffer); }
                playBoost() { /* No Boost sound */ } 
            }
            
            // --- 4. ENTITIES (Class definitions) ---

            class Mountains {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                constructor(canvas, GROUND_Y) {
                    this.ctx = canvas.getContext('2d');
                    this.width = canvas.width;
                    this.GROUND_Y = GROUND_Y;
                    this.mountainX = 0;
                }
                draw(GAME_SPEED) {
                    const speedFactor = 0.2; 
                    const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 

                    this.mountainX = (this.mountainX - FIXED_MOVEMENT * speedFactor) % this.width;

                    this.ctx.fillStyle = '#1e1e3f'; 

                    for (let i = 0; i < 2; i++) {
                        const xOffset = this.mountainX + i * this.width;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(xOffset - 100, this.GROUND_Y);
                        this.ctx.lineTo(xOffset + 250, this.GROUND_Y - 120);
                        this.ctx.lineTo(xOffset + 500, this.GROUND_Y - 70);
                        this.ctx.lineTo(xOffset + 850, this.GROUND_Y - 180);
                        this.ctx.lineTo(xOffset + 1000, this.GROUND_Y);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
            }

            class Player {
                constructor(canvas, GROUND_Y, MAX_JUMP_VELOCITY, soundManager) {
                    this.ctx = canvas.getContext('2d');
                    this.soundManager = soundManager;
                    this.GROUND_Y = GROUND_Y;
                    this.MAX_JUMP_VELOCITY = MAX_JUMP_VELOCITY; 

                    this.baseGravity = BASE_GRAVITY; 
                    this.baseMaxJumpVelocity = MAX_JUMP_VELOCITY; 

                    this.gravity = this.baseGravity; 
                    
                    this.initialY = GROUND_Y - 50;
                    this.x = 50; this.y = this.initialY; this.width = 30; this.height = 50;
                    this.velocityY = 0; this.isJumping = false;
                    this.hitboxOffset = {x: 5, y: 5, width: -10, height: -5}; 
                    this.successfulJumps = 0; 
                }

                reset() {
                    this.y = this.initialY;
                    this.velocityY = 0;
                    this.isJumping = false;
                    this.successfulJumps = 0; 
                    // ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶•‡ßá‡¶ï‡ßá ‡¶Æ‡¶æ‡¶® ‡¶®‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶¨‡ßá (‡¶®‡¶§‡ßÅ‡¶® ‡¶≤‡¶ú‡¶ø‡¶ï)
                    this.gravity = SETTINGS[SETTINGS.selected_speed].gravity; 
                    this.MAX_JUMP_VELOCITY = SETTINGS[SETTINGS.selected_speed].jump; 
                }

                draw(frameCount, gameState) {
                    // ... (‡¶Ü‡¶ó‡ßá‡¶∞ draw ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                    this.ctx.shadowColor = '#FF00FF'; 
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = '#FF00FF'; 
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.shadowBlur = 0; 

                    if (gameState === GameState.RUNNING && !this.isJumping) {
                        this.ctx.fillStyle = (frameCount % 8 < 4) ? '#00FFFF' : '#00AABB'; 
                        this.ctx.fillRect(this.x + 5, this.y + this.height - 10, 5, 10); 
                        this.ctx.fillRect(this.x + 20, this.y + this.height - 10, 5, 10);
                    }
                }
                
                update(dt) {
                    this.velocityY += this.gravity * dt;
                    this.y += this.velocityY * dt;

                    if (this.y + this.height > this.GROUND_Y) {
                        this.y = this.GROUND_Y - this.height;
                        this.velocityY = 0;
                        this.isJumping = false;
                    }
                }
                
                jump() {
                    if (!this.isJumping) {
                        this.isJumping = true;
                        this.velocityY = this.MAX_JUMP_VELOCITY; 
                        this.soundManager.playJump();
                    }
                }
                
                getHitbox() {
                    return {
                        x: this.x + this.hitboxOffset.x,
                        y: this.y + this.hitboxOffset.y,
                        width: this.width + this.hitboxOffset.width,
                        height: this.height + this.hitboxOffset.height
                    };
                }
            }

            class Obstacle {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ Obstacle ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                constructor(canvas, GROUND_Y, customHeight) {
                    this.ctx = canvas.getContext('2d');
                    this.width = Math.random() * 20 + 20;
                    this.height = customHeight || (Math.random() * 30 + 30);
                    this.y = GROUND_Y - this.height;
                    this.x = canvas.width;
                    this.color = '#FF00FF'; 
                    this.passed = false; 
                }
                draw() {
                    this.ctx.shadowColor = '#FF00FF';
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = this.color;
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.ctx.shadowBlur = 0;
                }
                update(GAME_SPEED) {
                    const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 
                    this.x -= FIXED_MOVEMENT;
                }
            }


            // --- 5. GAME LOGIC CORE ---
            
            // ‡¶ó‡ßç‡¶≤‡ßã‡¶¨‡¶æ‡¶≤ ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏
            let soundManager;
            let mountains;
            let player;
            let obstacles = [];

            function initializeGameObjects() {
                // AudioContext ‡¶á‡¶®‡¶ø‡¶∂‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶æ‡¶á‡¶ú‡ßá‡¶∂‡¶®: ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶ï‡¶∂‡¶®‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶ï‡¶≤ ‡¶π‡¶¨‡ßá
                if (!soundManager) soundManager = new SoundManager();
                
                // Player ‡¶è‡¶∞ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶¨‡ßá
                mountains = new Mountains(canvas, GROUND_Y); 
                player = new Player(canvas, GROUND_Y, SETTINGS[SETTINGS.selected_speed].jump, soundManager);
                obstacles = []; 
                GAME_SPEED = SETTINGS[SETTINGS.selected_speed].speed; // ‡¶ó‡ßá‡¶Æ‡ßá‡¶∞ ‡¶ó‡¶§‡¶ø ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ
            }

            function drawGround() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ drawGround ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                const FIXED_MOVEMENT = (GAME_SPEED / 1000) * (1000/60); 
                groundX = (groundX - FIXED_MOVEMENT) % GROUND_TILE_WIDTH;
                
                ctx.fillStyle = '#0f0a1c'; 
                ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
                
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 5;
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                for (let x = groundX; x < canvas.width; x += GROUND_TILE_WIDTH / 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, GROUND_Y);
                    ctx.lineTo(x, GROUND_Y + 10);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, GROUND_Y);
                ctx.lineTo(canvas.width, GROUND_Y);
                ctx.stroke();
            }

            function dynamicDifficulty() {
                // ... (AI logic - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                if (GAME_SPEED < MAX_SPEED) {
                    GAME_SPEED += (DIFFICULTY_INCREMENT / FPS_MULTIPLIER) * deltaTime;
                }

                if (score > lastBoostScore + BOOST_SCORE_INTERVAL) {
                    if (GAME_SPEED + SPEED_BOOST_AMOUNT < MAX_SPEED) {
                         GAME_SPEED += SPEED_BOOST_AMOUNT;
                    } else {
                        GAME_SPEED = MAX_SPEED;
                    }
                    lastBoostScore = score;
                }

                if (player && player.successfulJumps >= AI_SUCCESS_THRESHOLD) {
                    if (player.gravity < player.baseGravity + AI_GRAVITY_MODIFIER * 3) {
                        player.gravity += AI_GRAVITY_MODIFIER; 
                        player.MAX_JUMP_VELOCITY -= 50; 
                        player.successfulJumps = 0;
                    }
                }

                let minGap = 80;
                let maxGap = 200;
                const gapFactor = 1 - (GAME_SPEED / MAX_SPEED) * 0.7;
                const currentGap = minGap + (maxGap - minGap) * gapFactor;
                return currentGap;
            }

            let obstacleSpawnTimer = 0;
            function generateObstacles() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ generateObstacles ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                const spawnGap = dynamicDifficulty();

                if (obstacleSpawnTimer <= 0) {
                    let randomHeight = Math.random() * 30 + 30; 
                    const currentTime = performance.now();
                    
                    if (player && player.isJumping && player.velocityY < 0 && currentTime - lastObstacleSpawnedTime < 500) {
                         obstacleSpawnTimer = 200; 
                         return; 
                    }

                    if (lastObstacleHeight > 50 && Math.random() < 0.6) {
                        randomHeight = Math.random() * 15 + 20; 
                    }

                    const newObstacle = new Obstacle(canvas, GROUND_Y, randomHeight);
                    obstacles.push(newObstacle);

                    lastObstacleHeight = newObstacle.height;
                    lastObstacleSpawnedTime = currentTime;
                    obstacleSpawnTimer = spawnGap + Math.random() * 50;

                } else {
                    obstacleSpawnTimer -= deltaTime; 
                }
            }

            function trackPlayerSuccess() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ trackPlayerSuccess ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                if (!player) return;
                const playerBaseY = player.GROUND_Y - player.height;
                
                if (player.y < playerBaseY && player.velocityY > 0) {
                    const nearestObstacle = obstacles[0];
                    
                    if (nearestObstacle && nearestObstacle.x + nearestObstacle.width < player.x) {
                        if (!nearestObstacle.passed) { 
                            player.successfulJumps++; 
                            nearestObstacle.passed = true;
                        }
                    }
                }
            }

            function checkCollision() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ checkCollision ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                 if (!player) return false;
                const playerHitbox = player.getHitbox();
                for (let i = 0; i < obstacles.length; i++) {
                    let obs = obstacles[i];
                    
                    if (
                        playerHitbox.x < obs.x + obs.width &&
                        playerHitbox.x + playerHitbox.width > obs.x &&
                        playerHitbox.y < obs.y + obs.height &&
                        playerHitbox.y + playerHitbox.height > obs.y
                    ) {
                        endGame();
                        return true;
                    }
                }
                return false;
            }

            function resetGame() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ resetGame ‡¶ï‡ßã‡¶°) ...
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('runnerHighScore', highScore);
                }
                score = 0;
                // ‡¶ó‡¶§‡¶ø‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
                GAME_SPEED = SETTINGS[SETTINGS.selected_speed].speed;
                lastBoostScore = 0;
                obstacles = [];
                if (player) player.reset();
                frameCount = 0;
                highScore = localStorage.getItem('runnerHighScore') || 0;
            }

            function startGame() {
                if (gameState === GameState.RUNNING) return;
                
                // ‡¶ó‡ßá‡¶Æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶á‡¶®‡¶ø‡¶∂‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶æ‡¶á‡¶ú ‡¶ï‡¶∞‡¶æ
                if (!player) {
                    initializeGameObjects();
                }
                
                // AudioContext Resume/Start (‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶´‡¶ø‡¶ï‡ßç‡¶∏)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                gameState = GameState.RUNNING;
                startScreen.classList.remove('active');
                gameOverScreen.classList.remove('active');
                
                resetGame();
                lastTime = performance.now(); 
                gameLoop(lastTime);
            }

            function endGame() {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ endGame ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                if (gameState === GameState.OVER) return;
                gameState = GameState.OVER;
                cancelAnimationFrame(animationFrameId);
                
                document.getElementById('final-score').innerHTML = 
                    `Final Score: <span style="color:#FF00FF">${score.toString().padStart(6, '0')}</span><br>
                     High Score: ${highScore.toString().padStart(6, '0')}`;
                gameOverScreen.classList.add('active');
                if (soundManager) soundManager.playGameOver();
            }

            function gameLoop(currentTime) {
                // ... (‡¶Ü‡¶ó‡ßá‡¶∞ gameLoop ‡¶ï‡ßã‡¶° - ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§) ...
                deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                const dt = deltaTime / FPS_MULTIPLIER; 

                if (gameState !== GameState.RUNNING) {
                    if (jumpFlashTimer > 0) jumpFlashTimer -= dt;
                    return;
                }

                // A. ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
                player.update(dt); 
                generateObstacles();
                obstacles.forEach(obs => obs.update(GAME_SPEED));
                obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
                checkCollision();
                trackPlayerSuccess();

                // B. ‡¶°‡ßç‡¶∞
                ctx.fillStyle = '#0f0a1c'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mountains.draw(GAME_SPEED);
                drawGround();
                player.draw(frameCount, gameState);
                obstacles.forEach(obs => obs.draw());

                // C. UX/UI ‡¶´‡¶ø‡¶°‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï
                if (jumpFlashTimer > 0) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${jumpFlashTimer * 0.5})`; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    jumpFlashTimer -= dt * 2; 
                }

                // D. ‡¶∏‡ßç‡¶ï‡ßã‡¶∞‡¶ø‡¶Ç
                frameCount++;
                score += Math.floor(GAME_SPEED * dt); 
                
                let scoreText = score.toString().padStart(6, '0');
                if (score > highScore && score > 0) {
                    scoreText = `<span style="color:#FFD700; text-shadow: 0 0 5px #FFD700;">${scoreText}</span>`;
                }
                scoreDisplay.innerHTML = 'SCORE: ' + scoreText;

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- 6. INPUT HANDLING & SETTINGS (NEW) ---
            function handleJumpInput(event) {
                if (event && event.type === 'touchstart') { event.preventDefault(); }
                
                if (gameState === GameState.READY) {
                    startGame();
                } else if (gameState === GameState.RUNNING) {
                    if(player) player.jump();
                    jumpFlashTimer = 1; 
                }
            }
            
            // ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ ‡¶≠‡¶ø‡¶ú‡¶ø‡¶¨‡¶ø‡¶≤‡¶ø‡¶ü‡¶ø ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ
            function updateControlVisibility() {
                mobileJumpIcon.style.opacity = SETTINGS.controls_visible ? 1 : 0;
            }

            // ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç ‡¶¨‡¶æ‡¶ü‡¶® ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡¶æ
            document.querySelectorAll('.setting-button').forEach(button => {
                button.addEventListener('click', function() {
                    const settingType = this.dataset.setting;
                    const value = this.dataset.value;
                    
                    // ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü (‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü‡ßá‡¶° ‡¶è‡¶´‡ßá‡¶ï‡ßç‡¶ü)
                    document.querySelectorAll(`[data-setting="${settingType}"]`).forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    this.classList.add('selected');

                    if (settingType === 'speed') {
                        SETTINGS.selected_speed = value;
                    } else if (settingType === 'control') {
                        SETTINGS.controls_visible = (value === 'visible');
                        updateControlVisibility();
                    }
                });
            });


            // ‡¶á‡¶≠‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡¶ø‡¶∏‡ßá‡¶®‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Space' || event.code === 'ArrowUp') {
                    handleJumpInput(event);
                }
                if (gameState === GameState.OVER && (event.code === 'Enter' || event.code === 'KeyR')) {
                     location.reload(); 
                }
            });

            touchArea.addEventListener('mousedown', handleJumpInput); 
            touchArea.addEventListener('touchstart', handleJumpInput); 
            startButton.addEventListener('click', handleJumpInput); 

            // ‡¶π‡¶æ‡¶á ‡¶∏‡ßç‡¶ï‡ßã‡¶∞ ‡¶≤‡ßã‡¶° ‡¶ì ‡¶°‡¶ø‡¶∏‡¶™‡ßç‡¶≤‡ßá
            highScore = localStorage.getItem('runnerHighScore') || 0;
            document.getElementById('final-score').innerHTML = `High Score: ${highScore.toString().padStart(6, '0')}`;
            
            // ‡¶™‡ßç‡¶∞‡¶æ‡¶•‡¶Æ‡¶ø‡¶ï ‡¶≠‡¶ø‡¶ú‡¶ø‡¶¨‡¶ø‡¶≤‡¶ø‡¶ü‡¶ø ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ
            updateControlVisibility(); 
        });
    </script>
</body>
</html>
